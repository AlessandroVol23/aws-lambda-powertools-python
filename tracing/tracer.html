<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.7.5" />
<title>aws_lambda_powertools.tracing.tracer API documentation</title>
<meta name="description" content="" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>aws_lambda_powertools.tracing.tracer</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import copy
import functools
import logging
import os
from distutils.util import strtobool
from typing import Any, Callable, Dict

from aws_xray_sdk.core import models, patch_all, xray_recorder

is_cold_start = True
logger = logging.getLogger(__name__)
logger.setLevel(os.getenv(&#34;LOG_LEVEL&#34;, &#34;INFO&#34;))


class Tracer:
    &#34;&#34;&#34;Tracer using AWS-XRay to provide decorators with known defaults for Lambda functions

    When running locally, it detects whether it&#39;s running via SAM CLI,
    and if it is it returns dummy segments/subsegments instead.

    By default, it patches all available libraries supported by X-Ray SDK. Patching is
    automatically disabled when running locally via SAM CLI or by any other means. \n
    Ref: https://docs.aws.amazon.com/xray-sdk-for-python/latest/reference/thirdparty.html

    Tracer keeps a copy of its configuration as it can be instantiated more than once. This
    is useful when you are using your own middlewares and want to utilize an existing Tracer.
    Make sure to set `auto_patch=False` in subsequent Tracer instances to avoid double patching.

    Environment variables
    ---------------------
    POWERTOOLS_TRACE_DISABLED : str
        disable tracer (e.g. `&#34;true&#34;, &#34;True&#34;, &#34;TRUE&#34;`)
    POWERTOOLS_SERVICE_NAME : str
        service name

    Parameters
    ----------
    service: str
        Service name that will be appended in all tracing metadata
    auto_patch: bool
        Patch existing imported modules during initialization, by default True
    disabled: bool
        Flag to explicitly disable tracing, useful when running/testing locally.
        `Env POWERTOOLS_TRACE_DISABLED=&#34;true&#34;`

    Example
    -------
    **A Lambda function using Tracer**

        from aws_lambda_powertools.tracing import Tracer
        tracer = Tracer(service=&#34;greeting&#34;)

        @tracer.capture_method
        def greeting(name: str) -&gt; Dict:
            return {
                &#34;name&#34;: name
            }

        @tracer.capture_lambda_handler
        def handler(event: dict, context: Any) -&gt; Dict:
            print(&#34;Received event from Lambda...&#34;)
            response = greeting(name=&#34;Heitor&#34;)
            return response

    **Booking Lambda function using Tracer that adds additional annotation/metadata**

        from aws_lambda_powertools.tracing import Tracer
        tracer = Tracer(service=&#34;booking&#34;)

        @tracer.capture_method
        def confirm_booking(booking_id: str) -&gt; Dict:
                resp = add_confirmation(booking_id)

                tracer.put_annotation(&#34;BookingConfirmation&#34;, resp[&#39;requestId&#39;])
                tracer.put_metadata(&#34;Booking confirmation&#34;, resp)

                return resp

        @tracer.capture_lambda_handler
        def handler(event: dict, context: Any) -&gt; Dict:
            print(&#34;Received event from Lambda...&#34;)
            response = greeting(name=&#34;Heitor&#34;)
            return response

    **A Lambda function using service name via POWERTOOLS_SERVICE_NAME**

        export POWERTOOLS_SERVICE_NAME=&#34;booking&#34;
        from aws_lambda_powertools.tracing import Tracer
        tracer = Tracer()

        @tracer.capture_lambda_handler
        def handler(event: dict, context: Any) -&gt; Dict:
            print(&#34;Received event from Lambda...&#34;)
            response = greeting(name=&#34;Lessa&#34;)
            return response

    **Reuse an existing instance of Tracer anywhere in the code**

        # lambda_handler.py
        from aws_lambda_powertools.tracing import Tracer
        tracer = Tracer()

        @tracer.capture_lambda_handler
        def handler(event: dict, context: Any) -&gt; Dict:
            ...

        # utils.py
        from aws_lambda_powertools.tracing import Tracer
        tracer = Tracer()
        ...

    Returns
    -------
    Tracer
        Tracer instance with imported modules patched

    Limitations
    -----------
    * Async handler and methods not supported

    &#34;&#34;&#34;

    _default_config = {&#34;service&#34;: &#34;service_undefined&#34;, &#34;disabled&#34;: False, &#34;provider&#34;: xray_recorder, &#34;auto_patch&#34;: True}
    _config = copy.copy(_default_config)

    def __init__(
        self, service: str = None, disabled: bool = None, provider: xray_recorder = None, auto_patch: bool = None
    ):
        self.__build_config(service=service, disabled=disabled, provider=provider, auto_patch=auto_patch)
        self.provider = self._config[&#34;provider&#34;]
        self.disabled = self._config[&#34;disabled&#34;]
        self.service = self._config[&#34;service&#34;]
        self.auto_patch = self._config[&#34;auto_patch&#34;]

        if self.disabled:
            self.__disable_tracing_provider()

        if self.auto_patch:
            self.patch()

    def capture_lambda_handler(self, lambda_handler: Callable[[Dict, Any], Any] = None):
        &#34;&#34;&#34;Decorator to create subsegment for lambda handlers

        As Lambda follows (event, context) signature we can remove some of the boilerplate
        and also capture any exception any Lambda function throws or its response as metadata

        Example
        -------
        **Lambda function using capture_lambda_handler decorator**

            tracer = Tracer(service=&#34;payment&#34;)
            @tracer.capture_lambda_handler
            def handler(event, context)

        Parameters
        ----------
        method : Callable
            Method to annotate on

        Raises
        ------
        err
            Exception raised by method
        &#34;&#34;&#34;

        @functools.wraps(lambda_handler)
        def decorate(event, context):
            self.create_subsegment(name=f&#34;## {lambda_handler.__name__}&#34;)

            try:
                logger.debug(&#34;Calling lambda handler&#34;)
                response = lambda_handler(event, context)
                logger.debug(&#34;Received lambda handler response successfully&#34;)
                logger.debug(response)
                if response:
                    self.put_metadata(&#34;lambda handler response&#34;, response)
            except Exception as err:
                logger.debug(&#34;Exception received from lambda handler&#34;)
                self.put_metadata(f&#34;{self.service}_error&#34;, err)
                raise err
            finally:
                self.end_subsegment()

            return response

        return decorate

    def capture_method(self, method: Callable = None):
        &#34;&#34;&#34;Decorator to create subsegment for arbitrary functions

        It also captures both response and exceptions as metadata
        and creates a subsegment named `## &lt;method_name&gt;`

        Example
        -------
        **Custom function using capture_method decorator**

            tracer = Tracer(service=&#34;payment&#34;)
            @tracer.capture_method
            def some_function()

        Parameters
        ----------
        method : Callable
            Method to annotate on

        Raises
        ------
        err
            Exception raised by method
        &#34;&#34;&#34;

        @functools.wraps(method)
        def decorate(*args, **kwargs):
            method_name = f&#34;{method.__name__}&#34;
            self.create_subsegment(name=f&#34;## {method_name}&#34;)

            try:
                logger.debug(f&#34;Calling method: {method_name}&#34;)
                response = method(*args, **kwargs)
                logger.debug(f&#34;Received {method_name} response successfully&#34;)
                logger.debug(response)
                if response is not None:
                    self.put_metadata(f&#34;{method_name} response&#34;, response)
            except Exception as err:
                logger.debug(f&#34;Exception received from &#39;{method_name}&#39;&#39; method&#34;)
                self.put_metadata(f&#34;{method_name} error&#34;, err)
                raise err
            finally:
                self.end_subsegment()

            return response

        return decorate

    def put_annotation(self, key: str, value: Any):
        &#34;&#34;&#34;Adds annotation to existing segment or subsegment

        Example
        -------
        Custom annotation for a pseudo service named payment

            tracer = Tracer(service=&#34;payment&#34;)
            tracer.put_annotation(&#34;PaymentStatus&#34;, &#34;CONFIRMED&#34;)

        Parameters
        ----------
        key : str
            Annotation key (e.g. PaymentStatus)
        value : Any
            Value for annotation (e.g. &#34;CONFIRMED&#34;)
        &#34;&#34;&#34;
        # Will no longer be needed once #155 is resolved
        # https://github.com/aws/aws-xray-sdk-python/issues/155
        if self.disabled:
            return

        logger.debug(f&#34;Annotating on key &#39;{key}&#39;&#39; with &#39;{value}&#39;&#39;&#34;)
        self.provider.put_annotation(key=key, value=value)

    def put_metadata(self, key: str, value: object, namespace: str = None):
        &#34;&#34;&#34;Adds metadata to existing segment or subsegment

        Parameters
        ----------
        key : str
            Metadata key
        value : object
            Value for metadata
        namespace : str, optional
            Namespace that metadata will lie under, by default None

        Example
        -------
        Custom metadata for a pseudo service named payment

            tracer = Tracer(service=&#34;payment&#34;)
            response = collect_payment()
            tracer.put_metadata(&#34;Payment collection&#34;, response)
        &#34;&#34;&#34;
        # Will no longer be needed once #155 is resolved
        # https://github.com/aws/aws-xray-sdk-python/issues/155
        if self.disabled:
            return

        _namespace = namespace or self.service
        logger.debug(f&#34;Adding metadata on key &#39;{key}&#39;&#39; with &#39;{value}&#39;&#39; at namespace &#39;{namespace}&#39;&#39;&#34;)
        self.provider.put_metadata(key=key, value=value, namespace=_namespace)

    def create_subsegment(self, name: str) -&gt; models.subsegment:
        &#34;&#34;&#34;Creates subsegment or a dummy segment plus subsegment if tracing is disabled

        It also assumes Tracer would be instantiated statically so that cold starts are captured.

        Parameters
        ----------
        name : str
            Subsegment name

        Example
        -------
        Creates a genuine subsegment

            self.create_subsegment(name=&#34;a meaningful name&#34;)

        Returns
        -------
        models.subsegment
            AWS X-Ray Subsegment
        &#34;&#34;&#34;
        # Will no longer be needed once #155 is resolved
        # https://github.com/aws/aws-xray-sdk-python/issues/155
        subsegment = None

        if self.disabled:
            logger.debug(&#34;Tracing has been disabled, return dummy subsegment instead&#34;)
            segment = models.dummy_entities.DummySegment()
            subsegment = models.dummy_entities.DummySubsegment(segment)
        else:
            subsegment = self.provider.begin_subsegment(name=name)
            global is_cold_start
            if is_cold_start:
                logger.debug(&#34;Annotating cold start&#34;)
                subsegment.put_annotation(&#34;ColdStart&#34;, True)
                is_cold_start = False

        return subsegment

    def end_subsegment(self):
        &#34;&#34;&#34;Ends an existing subsegment

        Parameters
        ----------
        subsegment : models.subsegment
            Subsegment previously created
        &#34;&#34;&#34;
        if self.disabled:
            logger.debug(&#34;Tracing has been disabled, return instead&#34;)
            return

        self.provider.end_subsegment()

    def patch(self):
        &#34;&#34;&#34;Patch modules for instrumentation&#34;&#34;&#34;
        logger.debug(&#34;Patching modules...&#34;)

        is_lambda_emulator = os.getenv(&#34;AWS_SAM_LOCAL&#34;, False)
        is_lambda_env = os.getenv(&#34;LAMBDA_TASK_ROOT&#34;, False)

        if self.disabled:
            logger.debug(&#34;Tracing has been disabled, aborting patch&#34;)
            return

        if is_lambda_emulator or is_lambda_env:
            logger.debug(&#34;Running under SAM CLI env or not in Lambda; aborting patch&#34;)
            return

        patch_all()  # pragma: no cover

    def __disable_tracing_provider(self):
        &#34;&#34;&#34;Forcefully disables tracing and patching&#34;&#34;&#34;
        from aws_xray_sdk import global_sdk_config

        global_sdk_config.set_sdk_enabled(False)

    def __is_trace_disabled(self) -&gt; bool:
        &#34;&#34;&#34;Detects whether trace has been disabled

        Tracing is automatically disabled in the following conditions:

        1. Explicitly disabled via `TRACE_DISABLED` environment variable
        2. Running in Lambda Emulators where X-Ray Daemon will not be listening
        3. Explicitly disabled via constructor e.g `Tracer(disabled=True)`

        Returns
        -------
        bool
        &#34;&#34;&#34;
        logger.debug(&#34;Verifying whether Tracing has been disabled&#34;)
        is_lambda_emulator = os.getenv(&#34;AWS_SAM_LOCAL&#34;)
        env_option = str(os.getenv(&#34;POWERTOOLS_TRACE_DISABLED&#34;, &#34;false&#34;))
        disabled_env = strtobool(env_option)

        if disabled_env:
            logger.debug(&#34;Tracing has been disabled via env var POWERTOOLS_TRACE_DISABLED&#34;)
            return disabled_env

        if is_lambda_emulator:
            logger.debug(&#34;Running under SAM CLI env; Tracing has been disabled&#34;)
            return is_lambda_emulator

        return False

    def __build_config(
        self, service: str = None, disabled: bool = None, provider: xray_recorder = None, auto_patch: bool = None
    ):
        &#34;&#34;&#34; Populates Tracer config for new and existing initializations &#34;&#34;&#34;
        is_disabled = disabled if disabled is not None else self.__is_trace_disabled()
        is_service = service if service is not None else os.getenv(&#34;POWERTOOLS_SERVICE_NAME&#34;)

        self._config[&#34;provider&#34;] = provider if provider is not None else self._config[&#34;provider&#34;]
        self._config[&#34;auto_patch&#34;] = auto_patch if auto_patch is not None else self._config[&#34;auto_patch&#34;]
        self._config[&#34;service&#34;] = is_service if is_service else self._config[&#34;service&#34;]
        self._config[&#34;disabled&#34;] = is_disabled if is_disabled else self._config[&#34;disabled&#34;]

    @classmethod
    def _reset_config(cls):
        cls._config = copy.copy(cls._default_config)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="aws_lambda_powertools.tracing.tracer.Tracer"><code class="flex name class">
<span>class <span class="ident">Tracer</span></span>
<span>(</span><span>service=None, disabled=None, provider=None, auto_patch=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Tracer using AWS-XRay to provide decorators with known defaults for Lambda functions</p>
<p>When running locally, it detects whether it's running via SAM CLI,
and if it is it returns dummy segments/subsegments instead.</p>
<p>By default, it patches all available libraries supported by X-Ray SDK. Patching is
automatically disabled when running locally via SAM CLI or by any other means. </p>
<p>Ref: <a href="https://docs.aws.amazon.com/xray-sdk-for-python/latest/reference/thirdparty.html">https://docs.aws.amazon.com/xray-sdk-for-python/latest/reference/thirdparty.html</a></p>
<p>Tracer keeps a copy of its configuration as it can be instantiated more than once. This
is useful when you are using your own middlewares and want to utilize an existing Tracer.
Make sure to set <code>auto_patch=False</code> in subsequent Tracer instances to avoid double patching.</p>
<h2 id="environment-variables">Environment variables</h2>
<dl>
<dt><strong><code>POWERTOOLS_TRACE_DISABLED</code></strong> :&ensp;<code>str</code></dt>
<dd>disable tracer (e.g. <code>"true", "True", "TRUE"</code>)</dd>
<dt><strong><code>POWERTOOLS_SERVICE_NAME</code></strong> :&ensp;<code>str</code></dt>
<dd>service name</dd>
</dl>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>service</code></strong> :&ensp;<code>str</code></dt>
<dd>Service name that will be appended in all tracing metadata</dd>
<dt><strong><code>auto_patch</code></strong> :&ensp;<code>bool</code></dt>
<dd>Patch existing imported modules during initialization, by default True</dd>
<dt><strong><code>disabled</code></strong> :&ensp;<code>bool</code></dt>
<dd>Flag to explicitly disable tracing, useful when running/testing locally.
<code>Env POWERTOOLS_TRACE_DISABLED="true"</code></dd>
</dl>
<h2 id="example">Example</h2>
<p><strong>A Lambda function using Tracer</strong></p>
<pre><code>from aws_lambda_powertools.tracing import Tracer
tracer = Tracer(service="greeting")

@tracer.capture_method
def greeting(name: str) -&gt; Dict:
    return {
        "name": name
    }

@tracer.capture_lambda_handler
def handler(event: dict, context: Any) -&gt; Dict:
    print("Received event from Lambda...")
    response = greeting(name="Heitor")
    return response
</code></pre>
<p><strong>Booking Lambda function using Tracer that adds additional annotation/metadata</strong></p>
<pre><code>from aws_lambda_powertools.tracing import Tracer
tracer = Tracer(service="booking")

@tracer.capture_method
def confirm_booking(booking_id: str) -&gt; Dict:
        resp = add_confirmation(booking_id)

        tracer.put_annotation("BookingConfirmation", resp['requestId'])
        tracer.put_metadata("Booking confirmation", resp)

        return resp

@tracer.capture_lambda_handler
def handler(event: dict, context: Any) -&gt; Dict:
    print("Received event from Lambda...")
    response = greeting(name="Heitor")
    return response
</code></pre>
<p><strong>A Lambda function using service name via POWERTOOLS_SERVICE_NAME</strong></p>
<pre><code>export POWERTOOLS_SERVICE_NAME="booking"
from aws_lambda_powertools.tracing import Tracer
tracer = Tracer()

@tracer.capture_lambda_handler
def handler(event: dict, context: Any) -&gt; Dict:
    print("Received event from Lambda...")
    response = greeting(name="Lessa")
    return response
</code></pre>
<p><strong>Reuse an existing instance of Tracer anywhere in the code</strong></p>
<pre><code># lambda_handler.py
from aws_lambda_powertools.tracing import Tracer
tracer = Tracer()

@tracer.capture_lambda_handler
def handler(event: dict, context: Any) -&gt; Dict:
    ...

# utils.py
from aws_lambda_powertools.tracing import Tracer
tracer = Tracer()
...
</code></pre>
<h2 id="returns">Returns</h2>
<dl>
<dt><a title="aws_lambda_powertools.tracing.tracer.Tracer" href="#aws_lambda_powertools.tracing.tracer.Tracer"><code>Tracer</code></a></dt>
<dd>Tracer instance with imported modules patched</dd>
</dl>
<h2 id="limitations">Limitations</h2>
<ul>
<li>Async handler and methods not supported</li>
</ul></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Tracer:
    &#34;&#34;&#34;Tracer using AWS-XRay to provide decorators with known defaults for Lambda functions

    When running locally, it detects whether it&#39;s running via SAM CLI,
    and if it is it returns dummy segments/subsegments instead.

    By default, it patches all available libraries supported by X-Ray SDK. Patching is
    automatically disabled when running locally via SAM CLI or by any other means. \n
    Ref: https://docs.aws.amazon.com/xray-sdk-for-python/latest/reference/thirdparty.html

    Tracer keeps a copy of its configuration as it can be instantiated more than once. This
    is useful when you are using your own middlewares and want to utilize an existing Tracer.
    Make sure to set `auto_patch=False` in subsequent Tracer instances to avoid double patching.

    Environment variables
    ---------------------
    POWERTOOLS_TRACE_DISABLED : str
        disable tracer (e.g. `&#34;true&#34;, &#34;True&#34;, &#34;TRUE&#34;`)
    POWERTOOLS_SERVICE_NAME : str
        service name

    Parameters
    ----------
    service: str
        Service name that will be appended in all tracing metadata
    auto_patch: bool
        Patch existing imported modules during initialization, by default True
    disabled: bool
        Flag to explicitly disable tracing, useful when running/testing locally.
        `Env POWERTOOLS_TRACE_DISABLED=&#34;true&#34;`

    Example
    -------
    **A Lambda function using Tracer**

        from aws_lambda_powertools.tracing import Tracer
        tracer = Tracer(service=&#34;greeting&#34;)

        @tracer.capture_method
        def greeting(name: str) -&gt; Dict:
            return {
                &#34;name&#34;: name
            }

        @tracer.capture_lambda_handler
        def handler(event: dict, context: Any) -&gt; Dict:
            print(&#34;Received event from Lambda...&#34;)
            response = greeting(name=&#34;Heitor&#34;)
            return response

    **Booking Lambda function using Tracer that adds additional annotation/metadata**

        from aws_lambda_powertools.tracing import Tracer
        tracer = Tracer(service=&#34;booking&#34;)

        @tracer.capture_method
        def confirm_booking(booking_id: str) -&gt; Dict:
                resp = add_confirmation(booking_id)

                tracer.put_annotation(&#34;BookingConfirmation&#34;, resp[&#39;requestId&#39;])
                tracer.put_metadata(&#34;Booking confirmation&#34;, resp)

                return resp

        @tracer.capture_lambda_handler
        def handler(event: dict, context: Any) -&gt; Dict:
            print(&#34;Received event from Lambda...&#34;)
            response = greeting(name=&#34;Heitor&#34;)
            return response

    **A Lambda function using service name via POWERTOOLS_SERVICE_NAME**

        export POWERTOOLS_SERVICE_NAME=&#34;booking&#34;
        from aws_lambda_powertools.tracing import Tracer
        tracer = Tracer()

        @tracer.capture_lambda_handler
        def handler(event: dict, context: Any) -&gt; Dict:
            print(&#34;Received event from Lambda...&#34;)
            response = greeting(name=&#34;Lessa&#34;)
            return response

    **Reuse an existing instance of Tracer anywhere in the code**

        # lambda_handler.py
        from aws_lambda_powertools.tracing import Tracer
        tracer = Tracer()

        @tracer.capture_lambda_handler
        def handler(event: dict, context: Any) -&gt; Dict:
            ...

        # utils.py
        from aws_lambda_powertools.tracing import Tracer
        tracer = Tracer()
        ...

    Returns
    -------
    Tracer
        Tracer instance with imported modules patched

    Limitations
    -----------
    * Async handler and methods not supported

    &#34;&#34;&#34;

    _default_config = {&#34;service&#34;: &#34;service_undefined&#34;, &#34;disabled&#34;: False, &#34;provider&#34;: xray_recorder, &#34;auto_patch&#34;: True}
    _config = copy.copy(_default_config)

    def __init__(
        self, service: str = None, disabled: bool = None, provider: xray_recorder = None, auto_patch: bool = None
    ):
        self.__build_config(service=service, disabled=disabled, provider=provider, auto_patch=auto_patch)
        self.provider = self._config[&#34;provider&#34;]
        self.disabled = self._config[&#34;disabled&#34;]
        self.service = self._config[&#34;service&#34;]
        self.auto_patch = self._config[&#34;auto_patch&#34;]

        if self.disabled:
            self.__disable_tracing_provider()

        if self.auto_patch:
            self.patch()

    def capture_lambda_handler(self, lambda_handler: Callable[[Dict, Any], Any] = None):
        &#34;&#34;&#34;Decorator to create subsegment for lambda handlers

        As Lambda follows (event, context) signature we can remove some of the boilerplate
        and also capture any exception any Lambda function throws or its response as metadata

        Example
        -------
        **Lambda function using capture_lambda_handler decorator**

            tracer = Tracer(service=&#34;payment&#34;)
            @tracer.capture_lambda_handler
            def handler(event, context)

        Parameters
        ----------
        method : Callable
            Method to annotate on

        Raises
        ------
        err
            Exception raised by method
        &#34;&#34;&#34;

        @functools.wraps(lambda_handler)
        def decorate(event, context):
            self.create_subsegment(name=f&#34;## {lambda_handler.__name__}&#34;)

            try:
                logger.debug(&#34;Calling lambda handler&#34;)
                response = lambda_handler(event, context)
                logger.debug(&#34;Received lambda handler response successfully&#34;)
                logger.debug(response)
                if response:
                    self.put_metadata(&#34;lambda handler response&#34;, response)
            except Exception as err:
                logger.debug(&#34;Exception received from lambda handler&#34;)
                self.put_metadata(f&#34;{self.service}_error&#34;, err)
                raise err
            finally:
                self.end_subsegment()

            return response

        return decorate

    def capture_method(self, method: Callable = None):
        &#34;&#34;&#34;Decorator to create subsegment for arbitrary functions

        It also captures both response and exceptions as metadata
        and creates a subsegment named `## &lt;method_name&gt;`

        Example
        -------
        **Custom function using capture_method decorator**

            tracer = Tracer(service=&#34;payment&#34;)
            @tracer.capture_method
            def some_function()

        Parameters
        ----------
        method : Callable
            Method to annotate on

        Raises
        ------
        err
            Exception raised by method
        &#34;&#34;&#34;

        @functools.wraps(method)
        def decorate(*args, **kwargs):
            method_name = f&#34;{method.__name__}&#34;
            self.create_subsegment(name=f&#34;## {method_name}&#34;)

            try:
                logger.debug(f&#34;Calling method: {method_name}&#34;)
                response = method(*args, **kwargs)
                logger.debug(f&#34;Received {method_name} response successfully&#34;)
                logger.debug(response)
                if response is not None:
                    self.put_metadata(f&#34;{method_name} response&#34;, response)
            except Exception as err:
                logger.debug(f&#34;Exception received from &#39;{method_name}&#39;&#39; method&#34;)
                self.put_metadata(f&#34;{method_name} error&#34;, err)
                raise err
            finally:
                self.end_subsegment()

            return response

        return decorate

    def put_annotation(self, key: str, value: Any):
        &#34;&#34;&#34;Adds annotation to existing segment or subsegment

        Example
        -------
        Custom annotation for a pseudo service named payment

            tracer = Tracer(service=&#34;payment&#34;)
            tracer.put_annotation(&#34;PaymentStatus&#34;, &#34;CONFIRMED&#34;)

        Parameters
        ----------
        key : str
            Annotation key (e.g. PaymentStatus)
        value : Any
            Value for annotation (e.g. &#34;CONFIRMED&#34;)
        &#34;&#34;&#34;
        # Will no longer be needed once #155 is resolved
        # https://github.com/aws/aws-xray-sdk-python/issues/155
        if self.disabled:
            return

        logger.debug(f&#34;Annotating on key &#39;{key}&#39;&#39; with &#39;{value}&#39;&#39;&#34;)
        self.provider.put_annotation(key=key, value=value)

    def put_metadata(self, key: str, value: object, namespace: str = None):
        &#34;&#34;&#34;Adds metadata to existing segment or subsegment

        Parameters
        ----------
        key : str
            Metadata key
        value : object
            Value for metadata
        namespace : str, optional
            Namespace that metadata will lie under, by default None

        Example
        -------
        Custom metadata for a pseudo service named payment

            tracer = Tracer(service=&#34;payment&#34;)
            response = collect_payment()
            tracer.put_metadata(&#34;Payment collection&#34;, response)
        &#34;&#34;&#34;
        # Will no longer be needed once #155 is resolved
        # https://github.com/aws/aws-xray-sdk-python/issues/155
        if self.disabled:
            return

        _namespace = namespace or self.service
        logger.debug(f&#34;Adding metadata on key &#39;{key}&#39;&#39; with &#39;{value}&#39;&#39; at namespace &#39;{namespace}&#39;&#39;&#34;)
        self.provider.put_metadata(key=key, value=value, namespace=_namespace)

    def create_subsegment(self, name: str) -&gt; models.subsegment:
        &#34;&#34;&#34;Creates subsegment or a dummy segment plus subsegment if tracing is disabled

        It also assumes Tracer would be instantiated statically so that cold starts are captured.

        Parameters
        ----------
        name : str
            Subsegment name

        Example
        -------
        Creates a genuine subsegment

            self.create_subsegment(name=&#34;a meaningful name&#34;)

        Returns
        -------
        models.subsegment
            AWS X-Ray Subsegment
        &#34;&#34;&#34;
        # Will no longer be needed once #155 is resolved
        # https://github.com/aws/aws-xray-sdk-python/issues/155
        subsegment = None

        if self.disabled:
            logger.debug(&#34;Tracing has been disabled, return dummy subsegment instead&#34;)
            segment = models.dummy_entities.DummySegment()
            subsegment = models.dummy_entities.DummySubsegment(segment)
        else:
            subsegment = self.provider.begin_subsegment(name=name)
            global is_cold_start
            if is_cold_start:
                logger.debug(&#34;Annotating cold start&#34;)
                subsegment.put_annotation(&#34;ColdStart&#34;, True)
                is_cold_start = False

        return subsegment

    def end_subsegment(self):
        &#34;&#34;&#34;Ends an existing subsegment

        Parameters
        ----------
        subsegment : models.subsegment
            Subsegment previously created
        &#34;&#34;&#34;
        if self.disabled:
            logger.debug(&#34;Tracing has been disabled, return instead&#34;)
            return

        self.provider.end_subsegment()

    def patch(self):
        &#34;&#34;&#34;Patch modules for instrumentation&#34;&#34;&#34;
        logger.debug(&#34;Patching modules...&#34;)

        is_lambda_emulator = os.getenv(&#34;AWS_SAM_LOCAL&#34;, False)
        is_lambda_env = os.getenv(&#34;LAMBDA_TASK_ROOT&#34;, False)

        if self.disabled:
            logger.debug(&#34;Tracing has been disabled, aborting patch&#34;)
            return

        if is_lambda_emulator or is_lambda_env:
            logger.debug(&#34;Running under SAM CLI env or not in Lambda; aborting patch&#34;)
            return

        patch_all()  # pragma: no cover

    def __disable_tracing_provider(self):
        &#34;&#34;&#34;Forcefully disables tracing and patching&#34;&#34;&#34;
        from aws_xray_sdk import global_sdk_config

        global_sdk_config.set_sdk_enabled(False)

    def __is_trace_disabled(self) -&gt; bool:
        &#34;&#34;&#34;Detects whether trace has been disabled

        Tracing is automatically disabled in the following conditions:

        1. Explicitly disabled via `TRACE_DISABLED` environment variable
        2. Running in Lambda Emulators where X-Ray Daemon will not be listening
        3. Explicitly disabled via constructor e.g `Tracer(disabled=True)`

        Returns
        -------
        bool
        &#34;&#34;&#34;
        logger.debug(&#34;Verifying whether Tracing has been disabled&#34;)
        is_lambda_emulator = os.getenv(&#34;AWS_SAM_LOCAL&#34;)
        env_option = str(os.getenv(&#34;POWERTOOLS_TRACE_DISABLED&#34;, &#34;false&#34;))
        disabled_env = strtobool(env_option)

        if disabled_env:
            logger.debug(&#34;Tracing has been disabled via env var POWERTOOLS_TRACE_DISABLED&#34;)
            return disabled_env

        if is_lambda_emulator:
            logger.debug(&#34;Running under SAM CLI env; Tracing has been disabled&#34;)
            return is_lambda_emulator

        return False

    def __build_config(
        self, service: str = None, disabled: bool = None, provider: xray_recorder = None, auto_patch: bool = None
    ):
        &#34;&#34;&#34; Populates Tracer config for new and existing initializations &#34;&#34;&#34;
        is_disabled = disabled if disabled is not None else self.__is_trace_disabled()
        is_service = service if service is not None else os.getenv(&#34;POWERTOOLS_SERVICE_NAME&#34;)

        self._config[&#34;provider&#34;] = provider if provider is not None else self._config[&#34;provider&#34;]
        self._config[&#34;auto_patch&#34;] = auto_patch if auto_patch is not None else self._config[&#34;auto_patch&#34;]
        self._config[&#34;service&#34;] = is_service if is_service else self._config[&#34;service&#34;]
        self._config[&#34;disabled&#34;] = is_disabled if is_disabled else self._config[&#34;disabled&#34;]

    @classmethod
    def _reset_config(cls):
        cls._config = copy.copy(cls._default_config)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="aws_lambda_powertools.tracing.tracer.Tracer.capture_lambda_handler"><code class="name flex">
<span>def <span class="ident">capture_lambda_handler</span></span>(<span>self, lambda_handler=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Decorator to create subsegment for lambda handlers</p>
<p>As Lambda follows (event, context) signature we can remove some of the boilerplate
and also capture any exception any Lambda function throws or its response as metadata</p>
<h2 id="example">Example</h2>
<p><strong>Lambda function using capture_lambda_handler decorator</strong></p>
<pre><code>tracer = Tracer(service="payment")
@tracer.capture_lambda_handler
def handler(event, context)
</code></pre>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>method</code></strong> :&ensp;<code>Callable</code></dt>
<dd>Method to annotate on</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>err</code></dt>
<dd>Exception raised by method</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def capture_lambda_handler(self, lambda_handler: Callable[[Dict, Any], Any] = None):
    &#34;&#34;&#34;Decorator to create subsegment for lambda handlers

    As Lambda follows (event, context) signature we can remove some of the boilerplate
    and also capture any exception any Lambda function throws or its response as metadata

    Example
    -------
    **Lambda function using capture_lambda_handler decorator**

        tracer = Tracer(service=&#34;payment&#34;)
        @tracer.capture_lambda_handler
        def handler(event, context)

    Parameters
    ----------
    method : Callable
        Method to annotate on

    Raises
    ------
    err
        Exception raised by method
    &#34;&#34;&#34;

    @functools.wraps(lambda_handler)
    def decorate(event, context):
        self.create_subsegment(name=f&#34;## {lambda_handler.__name__}&#34;)

        try:
            logger.debug(&#34;Calling lambda handler&#34;)
            response = lambda_handler(event, context)
            logger.debug(&#34;Received lambda handler response successfully&#34;)
            logger.debug(response)
            if response:
                self.put_metadata(&#34;lambda handler response&#34;, response)
        except Exception as err:
            logger.debug(&#34;Exception received from lambda handler&#34;)
            self.put_metadata(f&#34;{self.service}_error&#34;, err)
            raise err
        finally:
            self.end_subsegment()

        return response

    return decorate</code></pre>
</details>
</dd>
<dt id="aws_lambda_powertools.tracing.tracer.Tracer.capture_method"><code class="name flex">
<span>def <span class="ident">capture_method</span></span>(<span>self, method=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Decorator to create subsegment for arbitrary functions</p>
<p>It also captures both response and exceptions as metadata
and creates a subsegment named <code>## &lt;method_name&gt;</code></p>
<h2 id="example">Example</h2>
<p><strong>Custom function using capture_method decorator</strong></p>
<pre><code>tracer = Tracer(service="payment")
@tracer.capture_method
def some_function()
</code></pre>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>method</code></strong> :&ensp;<code>Callable</code></dt>
<dd>Method to annotate on</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>err</code></dt>
<dd>Exception raised by method</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def capture_method(self, method: Callable = None):
    &#34;&#34;&#34;Decorator to create subsegment for arbitrary functions

    It also captures both response and exceptions as metadata
    and creates a subsegment named `## &lt;method_name&gt;`

    Example
    -------
    **Custom function using capture_method decorator**

        tracer = Tracer(service=&#34;payment&#34;)
        @tracer.capture_method
        def some_function()

    Parameters
    ----------
    method : Callable
        Method to annotate on

    Raises
    ------
    err
        Exception raised by method
    &#34;&#34;&#34;

    @functools.wraps(method)
    def decorate(*args, **kwargs):
        method_name = f&#34;{method.__name__}&#34;
        self.create_subsegment(name=f&#34;## {method_name}&#34;)

        try:
            logger.debug(f&#34;Calling method: {method_name}&#34;)
            response = method(*args, **kwargs)
            logger.debug(f&#34;Received {method_name} response successfully&#34;)
            logger.debug(response)
            if response is not None:
                self.put_metadata(f&#34;{method_name} response&#34;, response)
        except Exception as err:
            logger.debug(f&#34;Exception received from &#39;{method_name}&#39;&#39; method&#34;)
            self.put_metadata(f&#34;{method_name} error&#34;, err)
            raise err
        finally:
            self.end_subsegment()

        return response

    return decorate</code></pre>
</details>
</dd>
<dt id="aws_lambda_powertools.tracing.tracer.Tracer.create_subsegment"><code class="name flex">
<span>def <span class="ident">create_subsegment</span></span>(<span>self, name)</span>
</code></dt>
<dd>
<section class="desc"><p>Creates subsegment or a dummy segment plus subsegment if tracing is disabled</p>
<p>It also assumes Tracer would be instantiated statically so that cold starts are captured.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>Subsegment name</dd>
</dl>
<h2 id="example">Example</h2>
<p>Creates a genuine subsegment</p>
<pre><code>self.create_subsegment(name="a meaningful name")
</code></pre>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>models.subsegment</code></dt>
<dd>AWS X-Ray Subsegment</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_subsegment(self, name: str) -&gt; models.subsegment:
    &#34;&#34;&#34;Creates subsegment or a dummy segment plus subsegment if tracing is disabled

    It also assumes Tracer would be instantiated statically so that cold starts are captured.

    Parameters
    ----------
    name : str
        Subsegment name

    Example
    -------
    Creates a genuine subsegment

        self.create_subsegment(name=&#34;a meaningful name&#34;)

    Returns
    -------
    models.subsegment
        AWS X-Ray Subsegment
    &#34;&#34;&#34;
    # Will no longer be needed once #155 is resolved
    # https://github.com/aws/aws-xray-sdk-python/issues/155
    subsegment = None

    if self.disabled:
        logger.debug(&#34;Tracing has been disabled, return dummy subsegment instead&#34;)
        segment = models.dummy_entities.DummySegment()
        subsegment = models.dummy_entities.DummySubsegment(segment)
    else:
        subsegment = self.provider.begin_subsegment(name=name)
        global is_cold_start
        if is_cold_start:
            logger.debug(&#34;Annotating cold start&#34;)
            subsegment.put_annotation(&#34;ColdStart&#34;, True)
            is_cold_start = False

    return subsegment</code></pre>
</details>
</dd>
<dt id="aws_lambda_powertools.tracing.tracer.Tracer.end_subsegment"><code class="name flex">
<span>def <span class="ident">end_subsegment</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Ends an existing subsegment</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>subsegment</code></strong> :&ensp;<code>models.subsegment</code></dt>
<dd>Subsegment previously created</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def end_subsegment(self):
    &#34;&#34;&#34;Ends an existing subsegment

    Parameters
    ----------
    subsegment : models.subsegment
        Subsegment previously created
    &#34;&#34;&#34;
    if self.disabled:
        logger.debug(&#34;Tracing has been disabled, return instead&#34;)
        return

    self.provider.end_subsegment()</code></pre>
</details>
</dd>
<dt id="aws_lambda_powertools.tracing.tracer.Tracer.patch"><code class="name flex">
<span>def <span class="ident">patch</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Patch modules for instrumentation</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def patch(self):
    &#34;&#34;&#34;Patch modules for instrumentation&#34;&#34;&#34;
    logger.debug(&#34;Patching modules...&#34;)

    is_lambda_emulator = os.getenv(&#34;AWS_SAM_LOCAL&#34;, False)
    is_lambda_env = os.getenv(&#34;LAMBDA_TASK_ROOT&#34;, False)

    if self.disabled:
        logger.debug(&#34;Tracing has been disabled, aborting patch&#34;)
        return

    if is_lambda_emulator or is_lambda_env:
        logger.debug(&#34;Running under SAM CLI env or not in Lambda; aborting patch&#34;)
        return

    patch_all()  # pragma: no cover</code></pre>
</details>
</dd>
<dt id="aws_lambda_powertools.tracing.tracer.Tracer.put_annotation"><code class="name flex">
<span>def <span class="ident">put_annotation</span></span>(<span>self, key, value)</span>
</code></dt>
<dd>
<section class="desc"><p>Adds annotation to existing segment or subsegment</p>
<h2 id="example">Example</h2>
<p>Custom annotation for a pseudo service named payment</p>
<pre><code>tracer = Tracer(service="payment")
tracer.put_annotation("PaymentStatus", "CONFIRMED")
</code></pre>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>key</code></strong> :&ensp;<code>str</code></dt>
<dd>Annotation key (e.g. PaymentStatus)</dd>
<dt><strong><code>value</code></strong> :&ensp;<code>Any</code></dt>
<dd>Value for annotation (e.g. "CONFIRMED")</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def put_annotation(self, key: str, value: Any):
    &#34;&#34;&#34;Adds annotation to existing segment or subsegment

    Example
    -------
    Custom annotation for a pseudo service named payment

        tracer = Tracer(service=&#34;payment&#34;)
        tracer.put_annotation(&#34;PaymentStatus&#34;, &#34;CONFIRMED&#34;)

    Parameters
    ----------
    key : str
        Annotation key (e.g. PaymentStatus)
    value : Any
        Value for annotation (e.g. &#34;CONFIRMED&#34;)
    &#34;&#34;&#34;
    # Will no longer be needed once #155 is resolved
    # https://github.com/aws/aws-xray-sdk-python/issues/155
    if self.disabled:
        return

    logger.debug(f&#34;Annotating on key &#39;{key}&#39;&#39; with &#39;{value}&#39;&#39;&#34;)
    self.provider.put_annotation(key=key, value=value)</code></pre>
</details>
</dd>
<dt id="aws_lambda_powertools.tracing.tracer.Tracer.put_metadata"><code class="name flex">
<span>def <span class="ident">put_metadata</span></span>(<span>self, key, value, namespace=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Adds metadata to existing segment or subsegment</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>key</code></strong> :&ensp;<code>str</code></dt>
<dd>Metadata key</dd>
<dt><strong><code>value</code></strong> :&ensp;<code>object</code></dt>
<dd>Value for metadata</dd>
<dt><strong><code>namespace</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Namespace that metadata will lie under, by default None</dd>
</dl>
<h2 id="example">Example</h2>
<p>Custom metadata for a pseudo service named payment</p>
<pre><code>tracer = Tracer(service="payment")
response = collect_payment()
tracer.put_metadata("Payment collection", response)
</code></pre></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def put_metadata(self, key: str, value: object, namespace: str = None):
    &#34;&#34;&#34;Adds metadata to existing segment or subsegment

    Parameters
    ----------
    key : str
        Metadata key
    value : object
        Value for metadata
    namespace : str, optional
        Namespace that metadata will lie under, by default None

    Example
    -------
    Custom metadata for a pseudo service named payment

        tracer = Tracer(service=&#34;payment&#34;)
        response = collect_payment()
        tracer.put_metadata(&#34;Payment collection&#34;, response)
    &#34;&#34;&#34;
    # Will no longer be needed once #155 is resolved
    # https://github.com/aws/aws-xray-sdk-python/issues/155
    if self.disabled:
        return

    _namespace = namespace or self.service
    logger.debug(f&#34;Adding metadata on key &#39;{key}&#39;&#39; with &#39;{value}&#39;&#39; at namespace &#39;{namespace}&#39;&#39;&#34;)
    self.provider.put_metadata(key=key, value=value, namespace=_namespace)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="aws_lambda_powertools.tracing" href="index.html">aws_lambda_powertools.tracing</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="aws_lambda_powertools.tracing.tracer.Tracer" href="#aws_lambda_powertools.tracing.tracer.Tracer">Tracer</a></code></h4>
<ul class="">
<li><code><a title="aws_lambda_powertools.tracing.tracer.Tracer.capture_lambda_handler" href="#aws_lambda_powertools.tracing.tracer.Tracer.capture_lambda_handler">capture_lambda_handler</a></code></li>
<li><code><a title="aws_lambda_powertools.tracing.tracer.Tracer.capture_method" href="#aws_lambda_powertools.tracing.tracer.Tracer.capture_method">capture_method</a></code></li>
<li><code><a title="aws_lambda_powertools.tracing.tracer.Tracer.create_subsegment" href="#aws_lambda_powertools.tracing.tracer.Tracer.create_subsegment">create_subsegment</a></code></li>
<li><code><a title="aws_lambda_powertools.tracing.tracer.Tracer.end_subsegment" href="#aws_lambda_powertools.tracing.tracer.Tracer.end_subsegment">end_subsegment</a></code></li>
<li><code><a title="aws_lambda_powertools.tracing.tracer.Tracer.patch" href="#aws_lambda_powertools.tracing.tracer.Tracer.patch">patch</a></code></li>
<li><code><a title="aws_lambda_powertools.tracing.tracer.Tracer.put_annotation" href="#aws_lambda_powertools.tracing.tracer.Tracer.put_annotation">put_annotation</a></code></li>
<li><code><a title="aws_lambda_powertools.tracing.tracer.Tracer.put_metadata" href="#aws_lambda_powertools.tracing.tracer.Tracer.put_metadata">put_metadata</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.7.5</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>