<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.7.5" />
<title>aws_lambda_powertools.logging.logger API documentation</title>
<meta name="description" content="" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>aws_lambda_powertools.logging.logger</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import copy
import functools
import itertools
import json
import logging
import os
import random
import sys
import warnings
from distutils.util import strtobool
from typing import Any, Callable, Dict, Union

from ..helper.models import MetricUnit, build_lambda_context_model, build_metric_unit_from_str
from .exceptions import InvalidLoggerSamplingRateError

logger = logging.getLogger(__name__)

is_cold_start = True


def json_formatter(unserialized_value: Any):
    &#34;&#34;&#34;JSON custom serializer to cast unserialisable values to strings.

    Example
    -------

    **Serialize unserialisable value to string**

        class X: pass
        value = {&#34;x&#34;: X()}

        json.dumps(value, default=json_formatter)

    Parameters
    ----------
    unserialized_value: Any
        Python object unserializable by JSON
    &#34;&#34;&#34;
    return str(unserialized_value)


class JsonFormatter(logging.Formatter):
    &#34;&#34;&#34;AWS Lambda Logging formatter.

    Formats the log message as a JSON encoded string.  If the message is a
    dict it will be used directly.  If the message can be parsed as JSON, then
    the parse d value is used in the output record.

    Originally taken from https://gitlab.com/hadrien/aws_lambda_logging/

    &#34;&#34;&#34;

    def __init__(self, **kwargs):
        &#34;&#34;&#34;Return a JsonFormatter instance.

        The `json_default` kwarg is used to specify a formatter for otherwise
        unserialisable values.  It must not throw.  Defaults to a function that
        coerces the value to a string.

        Other kwargs are used to specify log field format strings.
        &#34;&#34;&#34;
        datefmt = kwargs.pop(&#34;datefmt&#34;, None)

        super(JsonFormatter, self).__init__(datefmt=datefmt)
        self.reserved_keys = [&#34;timestamp&#34;, &#34;level&#34;, &#34;location&#34;]
        self.format_dict = {
            &#34;timestamp&#34;: &#34;%(asctime)s&#34;,
            &#34;level&#34;: &#34;%(levelname)s&#34;,
            &#34;location&#34;: &#34;%(funcName)s:%(lineno)d&#34;,
        }
        self.format_dict.update(kwargs)
        self.default_json_formatter = kwargs.pop(&#34;json_default&#34;, json_formatter)

    def format(self, record):  # noqa: A003
        record_dict = record.__dict__.copy()
        record_dict[&#34;asctime&#34;] = self.formatTime(record, self.datefmt)

        log_dict = {}
        for key, value in self.format_dict.items():
            if value and key in self.reserved_keys:
                # converts default logging expr to its record value
                # e.g. &#39;%(asctime)s&#39; to &#39;2020-04-24 09:35:40,698&#39;
                log_dict[key] = value % record_dict
            else:
                log_dict[key] = value

        if isinstance(record_dict[&#34;msg&#34;], dict):
            log_dict[&#34;message&#34;] = record_dict[&#34;msg&#34;]
        else:
            log_dict[&#34;message&#34;] = record.getMessage()

            # Attempt to decode the message as JSON, if so, merge it with the
            # overall message for clarity.
            try:
                log_dict[&#34;message&#34;] = json.loads(log_dict[&#34;message&#34;])
            except (json.decoder.JSONDecodeError, TypeError, ValueError):
                pass

        if record.exc_info:
            # Cache the traceback text to avoid converting it multiple times
            # (it&#39;s constant anyway)
            # from logging.Formatter:format
            if not record.exc_text:
                record.exc_text = self.formatException(record.exc_info)

        if record.exc_text:
            log_dict[&#34;exception&#34;] = record.exc_text

        json_record = json.dumps(log_dict, default=self.default_json_formatter)

        if hasattr(json_record, &#34;decode&#34;):  # pragma: no cover
            json_record = json_record.decode(&#34;utf-8&#34;)

        return json_record


def logger_setup(
    service: str = None, level: str = None, sampling_rate: float = 0.0, legacy: bool = False, **kwargs
) -&gt; DeprecationWarning:
    &#34;&#34;&#34;DEPRECATED

    This will be removed when GA - Use `aws_lambda_powertools.logging.logger.Logger` instead

    Example
    -------
        **Logger class - Same UX**

        from aws_lambda_powertools import Logger
        logger = Logger(service=&#34;payment&#34;) # same env var still applies

    &#34;&#34;&#34;
    raise DeprecationWarning(&#34;Use Logger instead - This method will be removed when GA&#34;)


def logger_inject_lambda_context(
    lambda_handler: Callable[[Dict, Any], Any] = None, log_event: bool = False
) -&gt; DeprecationWarning:
    &#34;&#34;&#34;DEPRECATED

    This will be removed when GA - Use `aws_lambda_powertools.logging.logger.Logger` instead

    Example
    -------
        **Logger class - Same UX**

        from aws_lambda_powertools import Logger
        logger = Logger(service=&#34;payment&#34;) # same env var still applies
        @logger.inject_lambda_context
        def handler(evt, ctx):
            pass
    &#34;&#34;&#34;
    raise DeprecationWarning(&#34;Use Logger instead - This method will be removed when GA&#34;)


def _is_cold_start() -&gt; bool:
    &#34;&#34;&#34;Verifies whether is cold start

    Returns
    -------
    bool
        cold start bool value
    &#34;&#34;&#34;
    cold_start = False

    global is_cold_start
    if is_cold_start:
        cold_start = is_cold_start
        is_cold_start = False

    return cold_start


def log_metric(
    name: str, namespace: str, unit: MetricUnit, value: float = 0, service: str = &#34;service_undefined&#34;, **dimensions,
):
    &#34;&#34;&#34;Logs a custom metric in a statsD-esque format to stdout.

    **This will be removed when GA - Use `aws_lambda_powertools.metrics.metrics.Metrics` instead**

    Creating Custom Metrics synchronously impact on performance/execution time.
    Instead, log_metric prints a metric to CloudWatch Logs.
    That allows us to pick them up asynchronously via another Lambda function and create them as a metric.

    NOTE: It takes up to 9 dimensions by default, and Metric units are conveniently available via MetricUnit Enum.
    If service is not passed as arg or via env var, &#34;service_undefined&#34; will be used as dimension instead.

    **Output in CloudWatch Logs**: `MONITORING|&lt;metric_value&gt;|&lt;metric_unit&gt;|&lt;metric_name&gt;|&lt;namespace&gt;|&lt;dimensions&gt;`

    Serverless Application Repository App that creates custom metric from this log output:
    https://serverlessrepo.aws.amazon.com/applications/arn:aws:serverlessrepo:us-east-1:374852340823:applications~async-custom-metrics

    Environment variables
    ---------------------
    POWERTOOLS_SERVICE_NAME: str
        service name

    Parameters
    ----------
    name : str
        metric name, by default None
    namespace : str
        metric namespace (e.g. application name), by default None
    unit : MetricUnit, by default MetricUnit.Count
        metric unit enum value (e.g. MetricUnit.Seconds), by default None\n
        API Info: https://docs.aws.amazon.com/AmazonCloudWatch/latest/APIReference/API_MetricDatum.html
    value : float, optional
        metric value, by default 0
    service : str, optional
        service name used as dimension, by default &#34;service_undefined&#34;
    dimensions: dict, optional
        keyword arguments as additional dimensions (e.g. `customer=customerId`)

    Example
    -------
    **Log metric to count number of successful payments; define service via env var**

        $ export POWERTOOLS_SERVICE_NAME=&#34;payment&#34;
        from aws_lambda_powertools.logging import MetricUnit, log_metric
        log_metric(
            name=&#34;SuccessfulPayments&#34;,
            unit=MetricUnit.Count,
            value=1,
            namespace=&#34;DemoApp&#34;
        )

    **Log metric to count number of successful payments per campaign &amp; customer**

        from aws_lambda_powertools.logging import MetricUnit, log_metric
        log_metric(
            name=&#34;SuccessfulPayments&#34;,
            service=&#34;payment&#34;,
            unit=MetricUnit.Count,
            value=1,
            namespace=&#34;DemoApp&#34;,
            campaign=campaign_id,
            customer=customer_id
        )
    &#34;&#34;&#34;

    warnings.warn(message=&#34;This method will be removed in GA; use Metrics instead&#34;, category=DeprecationWarning)
    logger.debug(f&#34;Building new custom metric. Name: {name}, Unit: {unit}, Value: {value}, Dimensions: {dimensions}&#34;)
    service = os.getenv(&#34;POWERTOOLS_SERVICE_NAME&#34;) or service
    dimensions = __build_dimensions(**dimensions)
    unit = build_metric_unit_from_str(unit)

    metric = f&#34;MONITORING|{value}|{unit.name}|{name}|{namespace}|service={service}&#34;
    if dimensions:
        metric = f&#34;MONITORING|{value}|{unit.name}|{name}|{namespace}|service={service},{dimensions}&#34;

    print(metric)


def __build_dimensions(**dimensions) -&gt; str:
    &#34;&#34;&#34;Builds correct format for custom metric dimensions from kwargs

    Parameters
    ----------
    dimensions: dict, optional
        additional dimensions

    Returns
    -------
    str
        Dimensions in the form of &#34;key=value,key2=value2&#34;
    &#34;&#34;&#34;
    MAX_DIMENSIONS = 10
    dimension = &#34;&#34;

    # CloudWatch accepts a max of 10 dimensions per metric
    # We include service name as a dimension
    # so we take up to 9 values as additional dimensions
    # before we convert everything to a string of key=value
    dimensions_partition = dict(itertools.islice(dimensions.items(), MAX_DIMENSIONS))
    dimensions_list = [dimension + &#34;=&#34; + value for dimension, value in dimensions_partition.items() if value]
    dimension = &#34;,&#34;.join(dimensions_list)

    return dimension


class Logger(logging.Logger):
    &#34;&#34;&#34;Creates and setups a logger to format statements in JSON.

    Includes service name and any additional key=value into logs
    It also accepts both service name or level explicitly via env vars

    Environment variables
    ---------------------
    POWERTOOLS_SERVICE_NAME : str
        service name
    LOG_LEVEL: str, int
        logging level (e.g. INFO, DEBUG)
    POWERTOOLS_LOGGER_SAMPLE_RATE: float
        samping rate ranging from 0 to 1, 1 being 100% sampling

    Parameters
    ----------
    service : str, optional
        service name to be appended in logs, by default &#34;service_undefined&#34;
    level : str, optional
        logging.level, by default &#34;INFO&#34;
    sample_rate: float, optional
        sample rate for debug calls within execution context defaults to 0.0
    stream: sys.stdout, optional
        valid output for a logging stream, by default sys.stdout

    Example
    -------
    **Setups structured logging in JSON for Lambda functions with explicit service name**

        &gt;&gt;&gt; from aws_lambda_powertools import Logger
        &gt;&gt;&gt; logger = Logger(service=&#34;payment&#34;)
        &gt;&gt;&gt;
        &gt;&gt;&gt; def handler(event, context):
                logger.info(&#34;Hello&#34;)

    **Setups structured logging in JSON for Lambda functions using env vars**

        $ export POWERTOOLS_SERVICE_NAME=&#34;payment&#34;
        $ export POWERTOOLS_LOGGER_SAMPLE_RATE=0.01 # 1% debug sampling
        &gt;&gt;&gt; from aws_lambda_powertools import Logger
        &gt;&gt;&gt; logger = Logger()
        &gt;&gt;&gt;
        &gt;&gt;&gt; def handler(event, context):
                logger.info(&#34;Hello&#34;)

    **Append payment_id to previously setup structured log logger**

        &gt;&gt;&gt; from aws_lambda_powertools import Logger
        &gt;&gt;&gt; logger = Logger(service=&#34;payment&#34;)
        &gt;&gt;&gt;
        &gt;&gt;&gt; def handler(event, context):
                logger.structure_logs(append=True, payment_id=event[&#34;payment_id&#34;])
                logger.info(&#34;Hello&#34;)

    Parameters
    ----------
    logging : logging.Logger
        Inherits Logger
    service: str
        name of the service to create the logger for, &#34;service_undefined&#34; by default
    level: str, int
        log level, INFO by default
    sampling_rate: float
        debug log sampling rate, 0.0 by default
    stream: sys.stdout
        log stream, stdout by default

    Raises
    ------
    InvalidLoggerSamplingRateError
        When sampling rate provided is not a float
    &#34;&#34;&#34;

    def __init__(
        self,
        service: str = None,
        level: Union[str, int] = None,
        sampling_rate: float = None,
        stream: sys.stdout = None,
        **kwargs,
    ):
        self.service = service or os.getenv(&#34;POWERTOOLS_SERVICE_NAME&#34;) or &#34;service_undefined&#34;
        self.sampling_rate = sampling_rate or os.getenv(&#34;POWERTOOLS_LOGGER_SAMPLE_RATE&#34;) or 0.0
        self.log_level = level or os.getenv(&#34;LOG_LEVEL&#34;) or logging.INFO
        self.handler = logging.StreamHandler(stream) if stream is not None else logging.StreamHandler(sys.stdout)
        self._default_log_keys = {&#34;service&#34;: self.service, &#34;sampling_rate&#34;: self.sampling_rate}
        self.log_keys = copy.copy(self._default_log_keys)

        super().__init__(name=self.service, level=self.log_level)

        try:
            if self.sampling_rate and random.random() &lt;= float(self.sampling_rate):
                logger.debug(&#34;Setting log level to Debug due to sampling rate&#34;)
                self.log_level = logging.DEBUG
        except ValueError:
            raise InvalidLoggerSamplingRateError(
                f&#34;Expected a float value ranging 0 to 1, but received {self.sampling_rate} instead. Please review POWERTOOLS_LOGGER_SAMPLE_RATE environment variable.&#34;  # noqa E501
            )

        self.setLevel(self.log_level)
        self.structure_logs(**kwargs)
        self.addHandler(self.handler)

    def inject_lambda_context(self, lambda_handler: Callable[[Dict, Any], Any] = None, log_event: bool = False):
        &#34;&#34;&#34;Decorator to capture Lambda contextual info and inject into struct logging

        Parameters
        ----------
        log_event : bool, optional
            Instructs logger to log Lambda Event, by default False

        Environment variables
        ---------------------
        POWERTOOLS_LOGGER_LOG_EVENT : str
            instruct logger to log Lambda Event (e.g. `&#34;true&#34;, &#34;True&#34;, &#34;TRUE&#34;`)

        Example
        -------
        **Captures Lambda contextual runtime info (e.g memory, arn, req_id)**

            from aws_lambda_powertools import Logger

            logger = Logger(service=&#34;payment&#34;)

            @logger.inject_lambda_context
            def handler(event, context):
                logger.info(&#34;Hello&#34;)

        **Captures Lambda contextual runtime info and logs incoming request**

            from aws_lambda_powertools import Logger

            logger = Logger(service=&#34;payment&#34;)

            @logger.inject_lambda_context(log_event=True)
            def handler(event, context):
                logger.info(&#34;Hello&#34;)

        Returns
        -------
        decorate : Callable
            Decorated lambda handler
        &#34;&#34;&#34;

        # If handler is None we&#39;ve been called with parameters
        # Return a partial function with args filled
        if lambda_handler is None:
            logger.debug(&#34;Decorator called with parameters&#34;)
            return functools.partial(self.inject_lambda_context, log_event=log_event)

        log_event_env_option = str(os.getenv(&#34;POWERTOOLS_LOGGER_LOG_EVENT&#34;, &#34;false&#34;))
        log_event = strtobool(log_event_env_option) or log_event

        @functools.wraps(lambda_handler)
        def decorate(event, context):
            if log_event:
                logger.debug(&#34;Event received&#34;)
                self.info(event)

            lambda_context = build_lambda_context_model(context)
            cold_start = _is_cold_start()

            self.structure_logs(cold_start=cold_start, **lambda_context.__dict__)
            return lambda_handler(event, context)

        return decorate

    def structure_logs(self, append: bool = False, **kwargs):
        &#34;&#34;&#34;Sets logging formatting to JSON.

        Optionally, it can append keyword arguments
        to an existing logger so it is available
        across future log statements.

        Last keyword argument and value wins if duplicated.

        Parameters
        ----------
        append : bool, optional
            [description], by default False
        &#34;&#34;&#34;
        self.handler.setFormatter(JsonFormatter(**self._default_log_keys, **kwargs))

        if append:
            new_keys = {**self.log_keys, **kwargs}
            self.handler.setFormatter(JsonFormatter(**new_keys))

        self.log_keys.update(**kwargs)


def set_package_logger(
    level: Union[str, int] = logging.DEBUG, stream: sys.stdout = None, formatter: logging.Formatter = None
):
    &#34;&#34;&#34;Set an additional stream handler, formatter, and log level for aws_lambda_powertools package logger.

    **Package log by default is supressed (NullHandler), this should only used for debugging.
    This is separate from application Logger class utility**

    Example
    -------
    **Enables debug logging for AWS Lambda Powertools package**

        &gt;&gt;&gt; from aws_lambda_powertools.logging.logger import set_package_logger
        &gt;&gt;&gt; set_package_logger()

    Parameters
    ----------
    level: str, int
        log level, DEBUG by default
    stream: sys.stdout
        log stream, stdout by default
    formatter: logging.Formatter
        log formatter, &#34;%(asctime)s %(name)s [%(levelname)s] %(message)s&#34; by default
    &#34;&#34;&#34;
    if formatter is None:
        formatter = logging.Formatter(&#34;%(asctime)s %(name)s [%(levelname)s] %(message)s&#34;)

    if stream is None:
        stream = sys.stdout

    logger = logging.getLogger(&#34;aws_lambda_powertools&#34;)
    logger.setLevel(level)
    handler = logging.StreamHandler(stream)
    handler.setFormatter(formatter)
    logger.addHandler(handler)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="aws_lambda_powertools.logging.logger.json_formatter"><code class="name flex">
<span>def <span class="ident">json_formatter</span></span>(<span>unserialized_value)</span>
</code></dt>
<dd>
<section class="desc"><p>JSON custom serializer to cast unserialisable values to strings.</p>
<h2 id="example">Example</h2>
<p><strong>Serialize unserialisable value to string</strong></p>
<pre><code>class X: pass
value = {"x": X()}

json.dumps(value, default=json_formatter)
</code></pre>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>unserialized_value</code></strong> :&ensp;<code>Any</code></dt>
<dd>Python object unserializable by JSON</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def json_formatter(unserialized_value: Any):
    &#34;&#34;&#34;JSON custom serializer to cast unserialisable values to strings.

    Example
    -------

    **Serialize unserialisable value to string**

        class X: pass
        value = {&#34;x&#34;: X()}

        json.dumps(value, default=json_formatter)

    Parameters
    ----------
    unserialized_value: Any
        Python object unserializable by JSON
    &#34;&#34;&#34;
    return str(unserialized_value)</code></pre>
</details>
</dd>
<dt id="aws_lambda_powertools.logging.logger.log_metric"><code class="name flex">
<span>def <span class="ident">log_metric</span></span>(<span>name, namespace, unit, value=0, service='service_undefined', **dimensions)</span>
</code></dt>
<dd>
<section class="desc"><p>Logs a custom metric in a statsD-esque format to stdout.</p>
<p><strong>This will be removed when GA - Use <a title="aws_lambda_powertools.metrics.metrics.Metrics" href="../metrics/metrics.html#aws_lambda_powertools.metrics.metrics.Metrics"><code>Metrics</code></a> instead</strong></p>
<p>Creating Custom Metrics synchronously impact on performance/execution time.
Instead, log_metric prints a metric to CloudWatch Logs.
That allows us to pick them up asynchronously via another Lambda function and create them as a metric.</p>
<p>NOTE: It takes up to 9 dimensions by default, and Metric units are conveniently available via MetricUnit Enum.
If service is not passed as arg or via env var, "service_undefined" will be used as dimension instead.</p>
<p><strong>Output in CloudWatch Logs</strong>: <code>MONITORING|&lt;metric_value&gt;|&lt;metric_unit&gt;|&lt;metric_name&gt;|&lt;namespace&gt;|&lt;dimensions&gt;</code></p>
<p>Serverless Application Repository App that creates custom metric from this log output:
<a href="https://serverlessrepo.aws.amazon.com/applications/arn:aws:serverlessrepo:us-east-1:374852340823:applications~async-custom-metrics">https://serverlessrepo.aws.amazon.com/applications/arn:aws:serverlessrepo:us-east-1:374852340823:applications~async-custom-metrics</a></p>
<h2 id="environment-variables">Environment variables</h2>
<dl>
<dt><strong><code>POWERTOOLS_SERVICE_NAME</code></strong> :&ensp;<code>str</code></dt>
<dd>service name</dd>
</dl>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>metric name, by default None</dd>
<dt><strong><code>namespace</code></strong> :&ensp;<code>str</code></dt>
<dd>metric namespace (e.g. application name), by default None</dd>
<dt><strong><code>unit</code></strong> :&ensp;<code>MetricUnit</code>, <code>by</code> default <code>MetricUnit.Count</code></dt>
<dd>
<p>metric unit enum value (e.g. MetricUnit.Seconds), by default None</p>
<p>API Info: <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/APIReference/API_MetricDatum.html">https://docs.aws.amazon.com/AmazonCloudWatch/latest/APIReference/API_MetricDatum.html</a></p>
</dd>
<dt><strong><code>value</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>metric value, by default 0</dd>
<dt><strong><code>service</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>service name used as dimension, by default "service_undefined"</dd>
<dt><strong><code>dimensions</code></strong> :&ensp;<code>dict</code>, optional</dt>
<dd>keyword arguments as additional dimensions (e.g. <code>customer=customerId</code>)</dd>
</dl>
<h2 id="example">Example</h2>
<p><strong>Log metric to count number of successful payments; define service via env var</strong></p>
<pre><code>$ export POWERTOOLS_SERVICE_NAME="payment"
from aws_lambda_powertools.logging import MetricUnit, log_metric
log_metric(
    name="SuccessfulPayments",
    unit=MetricUnit.Count,
    value=1,
    namespace="DemoApp"
)
</code></pre>
<p><strong>Log metric to count number of successful payments per campaign &amp; customer</strong></p>
<pre><code>from aws_lambda_powertools.logging import MetricUnit, log_metric
log_metric(
    name="SuccessfulPayments",
    service="payment",
    unit=MetricUnit.Count,
    value=1,
    namespace="DemoApp",
    campaign=campaign_id,
    customer=customer_id
)
</code></pre></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def log_metric(
    name: str, namespace: str, unit: MetricUnit, value: float = 0, service: str = &#34;service_undefined&#34;, **dimensions,
):
    &#34;&#34;&#34;Logs a custom metric in a statsD-esque format to stdout.

    **This will be removed when GA - Use `aws_lambda_powertools.metrics.metrics.Metrics` instead**

    Creating Custom Metrics synchronously impact on performance/execution time.
    Instead, log_metric prints a metric to CloudWatch Logs.
    That allows us to pick them up asynchronously via another Lambda function and create them as a metric.

    NOTE: It takes up to 9 dimensions by default, and Metric units are conveniently available via MetricUnit Enum.
    If service is not passed as arg or via env var, &#34;service_undefined&#34; will be used as dimension instead.

    **Output in CloudWatch Logs**: `MONITORING|&lt;metric_value&gt;|&lt;metric_unit&gt;|&lt;metric_name&gt;|&lt;namespace&gt;|&lt;dimensions&gt;`

    Serverless Application Repository App that creates custom metric from this log output:
    https://serverlessrepo.aws.amazon.com/applications/arn:aws:serverlessrepo:us-east-1:374852340823:applications~async-custom-metrics

    Environment variables
    ---------------------
    POWERTOOLS_SERVICE_NAME: str
        service name

    Parameters
    ----------
    name : str
        metric name, by default None
    namespace : str
        metric namespace (e.g. application name), by default None
    unit : MetricUnit, by default MetricUnit.Count
        metric unit enum value (e.g. MetricUnit.Seconds), by default None\n
        API Info: https://docs.aws.amazon.com/AmazonCloudWatch/latest/APIReference/API_MetricDatum.html
    value : float, optional
        metric value, by default 0
    service : str, optional
        service name used as dimension, by default &#34;service_undefined&#34;
    dimensions: dict, optional
        keyword arguments as additional dimensions (e.g. `customer=customerId`)

    Example
    -------
    **Log metric to count number of successful payments; define service via env var**

        $ export POWERTOOLS_SERVICE_NAME=&#34;payment&#34;
        from aws_lambda_powertools.logging import MetricUnit, log_metric
        log_metric(
            name=&#34;SuccessfulPayments&#34;,
            unit=MetricUnit.Count,
            value=1,
            namespace=&#34;DemoApp&#34;
        )

    **Log metric to count number of successful payments per campaign &amp; customer**

        from aws_lambda_powertools.logging import MetricUnit, log_metric
        log_metric(
            name=&#34;SuccessfulPayments&#34;,
            service=&#34;payment&#34;,
            unit=MetricUnit.Count,
            value=1,
            namespace=&#34;DemoApp&#34;,
            campaign=campaign_id,
            customer=customer_id
        )
    &#34;&#34;&#34;

    warnings.warn(message=&#34;This method will be removed in GA; use Metrics instead&#34;, category=DeprecationWarning)
    logger.debug(f&#34;Building new custom metric. Name: {name}, Unit: {unit}, Value: {value}, Dimensions: {dimensions}&#34;)
    service = os.getenv(&#34;POWERTOOLS_SERVICE_NAME&#34;) or service
    dimensions = __build_dimensions(**dimensions)
    unit = build_metric_unit_from_str(unit)

    metric = f&#34;MONITORING|{value}|{unit.name}|{name}|{namespace}|service={service}&#34;
    if dimensions:
        metric = f&#34;MONITORING|{value}|{unit.name}|{name}|{namespace}|service={service},{dimensions}&#34;

    print(metric)</code></pre>
</details>
</dd>
<dt id="aws_lambda_powertools.logging.logger.logger_inject_lambda_context"><code class="name flex">
<span>def <span class="ident">logger_inject_lambda_context</span></span>(<span>lambda_handler=None, log_event=False)</span>
</code></dt>
<dd>
<section class="desc"><p>DEPRECATED</p>
<p>This will be removed when GA - Use <a title="aws_lambda_powertools.logging.logger.Logger" href="#aws_lambda_powertools.logging.logger.Logger"><code>Logger</code></a> instead</p>
<h2 id="example">Example</h2>
<pre><code>**Logger class - Same UX**

from aws_lambda_powertools import Logger
logger = Logger(service="payment") # same env var still applies
@logger.inject_lambda_context
def handler(evt, ctx):
    pass
</code></pre></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def logger_inject_lambda_context(
    lambda_handler: Callable[[Dict, Any], Any] = None, log_event: bool = False
) -&gt; DeprecationWarning:
    &#34;&#34;&#34;DEPRECATED

    This will be removed when GA - Use `aws_lambda_powertools.logging.logger.Logger` instead

    Example
    -------
        **Logger class - Same UX**

        from aws_lambda_powertools import Logger
        logger = Logger(service=&#34;payment&#34;) # same env var still applies
        @logger.inject_lambda_context
        def handler(evt, ctx):
            pass
    &#34;&#34;&#34;
    raise DeprecationWarning(&#34;Use Logger instead - This method will be removed when GA&#34;)</code></pre>
</details>
</dd>
<dt id="aws_lambda_powertools.logging.logger.logger_setup"><code class="name flex">
<span>def <span class="ident">logger_setup</span></span>(<span>service=None, level=None, sampling_rate=0.0, legacy=False, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>DEPRECATED</p>
<p>This will be removed when GA - Use <a title="aws_lambda_powertools.logging.logger.Logger" href="#aws_lambda_powertools.logging.logger.Logger"><code>Logger</code></a> instead</p>
<h2 id="example">Example</h2>
<pre><code>**Logger class - Same UX**

from aws_lambda_powertools import Logger
logger = Logger(service="payment") # same env var still applies
</code></pre></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def logger_setup(
    service: str = None, level: str = None, sampling_rate: float = 0.0, legacy: bool = False, **kwargs
) -&gt; DeprecationWarning:
    &#34;&#34;&#34;DEPRECATED

    This will be removed when GA - Use `aws_lambda_powertools.logging.logger.Logger` instead

    Example
    -------
        **Logger class - Same UX**

        from aws_lambda_powertools import Logger
        logger = Logger(service=&#34;payment&#34;) # same env var still applies

    &#34;&#34;&#34;
    raise DeprecationWarning(&#34;Use Logger instead - This method will be removed when GA&#34;)</code></pre>
</details>
</dd>
<dt id="aws_lambda_powertools.logging.logger.set_package_logger"><code class="name flex">
<span>def <span class="ident">set_package_logger</span></span>(<span>level=10, stream=None, formatter=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Set an additional stream handler, formatter, and log level for aws_lambda_powertools package logger.</p>
<p><strong>Package log by default is supressed (NullHandler), this should only used for debugging.
This is separate from application Logger class utility</strong></p>
<h2 id="example">Example</h2>
<p><strong>Enables debug logging for AWS Lambda Powertools package</strong></p>
<pre><code>&gt;&gt;&gt; from aws_lambda_powertools.logging.logger import set_package_logger
&gt;&gt;&gt; set_package_logger()
</code></pre>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>level</code></strong> :&ensp;<code>str</code>, <code>int</code></dt>
<dd>log level, DEBUG by default</dd>
<dt><strong><code>stream</code></strong> :&ensp;<code>sys.stdout</code></dt>
<dd>log stream, stdout by default</dd>
<dt><strong><code>formatter</code></strong> :&ensp;<code>logging.Formatter</code></dt>
<dd>log formatter, "%(asctime)s %(name)s [%(levelname)s] %(message)s" by default</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_package_logger(
    level: Union[str, int] = logging.DEBUG, stream: sys.stdout = None, formatter: logging.Formatter = None
):
    &#34;&#34;&#34;Set an additional stream handler, formatter, and log level for aws_lambda_powertools package logger.

    **Package log by default is supressed (NullHandler), this should only used for debugging.
    This is separate from application Logger class utility**

    Example
    -------
    **Enables debug logging for AWS Lambda Powertools package**

        &gt;&gt;&gt; from aws_lambda_powertools.logging.logger import set_package_logger
        &gt;&gt;&gt; set_package_logger()

    Parameters
    ----------
    level: str, int
        log level, DEBUG by default
    stream: sys.stdout
        log stream, stdout by default
    formatter: logging.Formatter
        log formatter, &#34;%(asctime)s %(name)s [%(levelname)s] %(message)s&#34; by default
    &#34;&#34;&#34;
    if formatter is None:
        formatter = logging.Formatter(&#34;%(asctime)s %(name)s [%(levelname)s] %(message)s&#34;)

    if stream is None:
        stream = sys.stdout

    logger = logging.getLogger(&#34;aws_lambda_powertools&#34;)
    logger.setLevel(level)
    handler = logging.StreamHandler(stream)
    handler.setFormatter(formatter)
    logger.addHandler(handler)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="aws_lambda_powertools.logging.logger.JsonFormatter"><code class="flex name class">
<span>class <span class="ident">JsonFormatter</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>AWS Lambda Logging formatter.</p>
<p>Formats the log message as a JSON encoded string.
If the message is a
dict it will be used directly.
If the message can be parsed as JSON, then
the parse d value is used in the output record.</p>
<p>Originally taken from <a href="https://gitlab.com/hadrien/aws_lambda_logging/">https://gitlab.com/hadrien/aws_lambda_logging/</a></p>
<p>Return a JsonFormatter instance.</p>
<p>The <code>json_default</code> kwarg is used to specify a formatter for otherwise
unserialisable values.
It must not throw.
Defaults to a function that
coerces the value to a string.</p>
<p>Other kwargs are used to specify log field format strings.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class JsonFormatter(logging.Formatter):
    &#34;&#34;&#34;AWS Lambda Logging formatter.

    Formats the log message as a JSON encoded string.  If the message is a
    dict it will be used directly.  If the message can be parsed as JSON, then
    the parse d value is used in the output record.

    Originally taken from https://gitlab.com/hadrien/aws_lambda_logging/

    &#34;&#34;&#34;

    def __init__(self, **kwargs):
        &#34;&#34;&#34;Return a JsonFormatter instance.

        The `json_default` kwarg is used to specify a formatter for otherwise
        unserialisable values.  It must not throw.  Defaults to a function that
        coerces the value to a string.

        Other kwargs are used to specify log field format strings.
        &#34;&#34;&#34;
        datefmt = kwargs.pop(&#34;datefmt&#34;, None)

        super(JsonFormatter, self).__init__(datefmt=datefmt)
        self.reserved_keys = [&#34;timestamp&#34;, &#34;level&#34;, &#34;location&#34;]
        self.format_dict = {
            &#34;timestamp&#34;: &#34;%(asctime)s&#34;,
            &#34;level&#34;: &#34;%(levelname)s&#34;,
            &#34;location&#34;: &#34;%(funcName)s:%(lineno)d&#34;,
        }
        self.format_dict.update(kwargs)
        self.default_json_formatter = kwargs.pop(&#34;json_default&#34;, json_formatter)

    def format(self, record):  # noqa: A003
        record_dict = record.__dict__.copy()
        record_dict[&#34;asctime&#34;] = self.formatTime(record, self.datefmt)

        log_dict = {}
        for key, value in self.format_dict.items():
            if value and key in self.reserved_keys:
                # converts default logging expr to its record value
                # e.g. &#39;%(asctime)s&#39; to &#39;2020-04-24 09:35:40,698&#39;
                log_dict[key] = value % record_dict
            else:
                log_dict[key] = value

        if isinstance(record_dict[&#34;msg&#34;], dict):
            log_dict[&#34;message&#34;] = record_dict[&#34;msg&#34;]
        else:
            log_dict[&#34;message&#34;] = record.getMessage()

            # Attempt to decode the message as JSON, if so, merge it with the
            # overall message for clarity.
            try:
                log_dict[&#34;message&#34;] = json.loads(log_dict[&#34;message&#34;])
            except (json.decoder.JSONDecodeError, TypeError, ValueError):
                pass

        if record.exc_info:
            # Cache the traceback text to avoid converting it multiple times
            # (it&#39;s constant anyway)
            # from logging.Formatter:format
            if not record.exc_text:
                record.exc_text = self.formatException(record.exc_info)

        if record.exc_text:
            log_dict[&#34;exception&#34;] = record.exc_text

        json_record = json.dumps(log_dict, default=self.default_json_formatter)

        if hasattr(json_record, &#34;decode&#34;):  # pragma: no cover
            json_record = json_record.decode(&#34;utf-8&#34;)

        return json_record</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>logging.Formatter</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="aws_lambda_powertools.logging.logger.JsonFormatter.format"><code class="name flex">
<span>def <span class="ident">format</span></span>(<span>self, record)</span>
</code></dt>
<dd>
<section class="desc"><p>Format the specified record as text.</p>
<p>The record's attribute dictionary is used as the operand to a
string formatting operation which yields the returned string.
Before formatting the dictionary, a couple of preparatory steps
are carried out. The message attribute of the record is computed
using LogRecord.getMessage(). If the formatting string uses the
time (as determined by a call to usesTime(), formatTime() is
called to format the event time. If there is exception information,
it is formatted using formatException() and appended to the message.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def format(self, record):  # noqa: A003
    record_dict = record.__dict__.copy()
    record_dict[&#34;asctime&#34;] = self.formatTime(record, self.datefmt)

    log_dict = {}
    for key, value in self.format_dict.items():
        if value and key in self.reserved_keys:
            # converts default logging expr to its record value
            # e.g. &#39;%(asctime)s&#39; to &#39;2020-04-24 09:35:40,698&#39;
            log_dict[key] = value % record_dict
        else:
            log_dict[key] = value

    if isinstance(record_dict[&#34;msg&#34;], dict):
        log_dict[&#34;message&#34;] = record_dict[&#34;msg&#34;]
    else:
        log_dict[&#34;message&#34;] = record.getMessage()

        # Attempt to decode the message as JSON, if so, merge it with the
        # overall message for clarity.
        try:
            log_dict[&#34;message&#34;] = json.loads(log_dict[&#34;message&#34;])
        except (json.decoder.JSONDecodeError, TypeError, ValueError):
            pass

    if record.exc_info:
        # Cache the traceback text to avoid converting it multiple times
        # (it&#39;s constant anyway)
        # from logging.Formatter:format
        if not record.exc_text:
            record.exc_text = self.formatException(record.exc_info)

    if record.exc_text:
        log_dict[&#34;exception&#34;] = record.exc_text

    json_record = json.dumps(log_dict, default=self.default_json_formatter)

    if hasattr(json_record, &#34;decode&#34;):  # pragma: no cover
        json_record = json_record.decode(&#34;utf-8&#34;)

    return json_record</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="aws_lambda_powertools.logging.logger.Logger"><code class="flex name class">
<span>class <span class="ident">Logger</span></span>
<span>(</span><span>service=None, level=None, sampling_rate=None, stream=None, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Creates and setups a logger to format statements in JSON.</p>
<p>Includes service name and any additional key=value into logs
It also accepts both service name or level explicitly via env vars</p>
<h2 id="environment-variables">Environment variables</h2>
<dl>
<dt><strong><code>POWERTOOLS_SERVICE_NAME</code></strong> :&ensp;<code>str</code></dt>
<dd>service name</dd>
<dt><strong><code>LOG_LEVEL</code></strong> :&ensp;<code>str</code>, <code>int</code></dt>
<dd>logging level (e.g. INFO, DEBUG)</dd>
<dt><strong><code>POWERTOOLS_LOGGER_SAMPLE_RATE</code></strong> :&ensp;<code>float</code></dt>
<dd>samping rate ranging from 0 to 1, 1 being 100% sampling</dd>
</dl>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>service</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>service name to be appended in logs, by default "service_undefined"</dd>
<dt><strong><code>level</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>logging.level, by default "INFO"</dd>
<dt><strong><code>sample_rate</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>sample rate for debug calls within execution context defaults to 0.0</dd>
<dt><strong><code>stream</code></strong> :&ensp;<code>sys.stdout</code>, optional</dt>
<dd>valid output for a logging stream, by default sys.stdout</dd>
</dl>
<h2 id="example">Example</h2>
<p><strong>Setups structured logging in JSON for Lambda functions with explicit service name</strong></p>
<pre><code>&gt;&gt;&gt; from aws_lambda_powertools import Logger
&gt;&gt;&gt; logger = Logger(service="payment")
&gt;&gt;&gt;
&gt;&gt;&gt; def handler(event, context):
        logger.info("Hello")
</code></pre>
<p><strong>Setups structured logging in JSON for Lambda functions using env vars</strong></p>
<pre><code>$ export POWERTOOLS_SERVICE_NAME="payment"
$ export POWERTOOLS_LOGGER_SAMPLE_RATE=0.01 # 1% debug sampling
&gt;&gt;&gt; from aws_lambda_powertools import Logger
&gt;&gt;&gt; logger = Logger()
&gt;&gt;&gt;
&gt;&gt;&gt; def handler(event, context):
        logger.info("Hello")
</code></pre>
<p><strong>Append payment_id to previously setup structured log logger</strong></p>
<pre><code>&gt;&gt;&gt; from aws_lambda_powertools import Logger
&gt;&gt;&gt; logger = Logger(service="payment")
&gt;&gt;&gt;
&gt;&gt;&gt; def handler(event, context):
        logger.structure_logs(append=True, payment_id=event["payment_id"])
        logger.info("Hello")
</code></pre>
<h2 id="parameters_1">Parameters</h2>
<dl>
<dt><strong><code>logging</code></strong> :&ensp;<code>logging.Logger</code></dt>
<dd>Inherits Logger</dd>
<dt><strong><code>service</code></strong> :&ensp;<code>str</code></dt>
<dd>name of the service to create the logger for, "service_undefined" by default</dd>
<dt><strong><code>level</code></strong> :&ensp;<code>str</code>, <code>int</code></dt>
<dd>log level, INFO by default</dd>
<dt><strong><code>sampling_rate</code></strong> :&ensp;<code>float</code></dt>
<dd>debug log sampling rate, 0.0 by default</dd>
<dt><strong><code>stream</code></strong> :&ensp;<code>sys.stdout</code></dt>
<dd>log stream, stdout by default</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>InvalidLoggerSamplingRateError</code></dt>
<dd>When sampling rate provided is not a float</dd>
</dl>
<p>Initialize the logger with a name and an optional level.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Logger(logging.Logger):
    &#34;&#34;&#34;Creates and setups a logger to format statements in JSON.

    Includes service name and any additional key=value into logs
    It also accepts both service name or level explicitly via env vars

    Environment variables
    ---------------------
    POWERTOOLS_SERVICE_NAME : str
        service name
    LOG_LEVEL: str, int
        logging level (e.g. INFO, DEBUG)
    POWERTOOLS_LOGGER_SAMPLE_RATE: float
        samping rate ranging from 0 to 1, 1 being 100% sampling

    Parameters
    ----------
    service : str, optional
        service name to be appended in logs, by default &#34;service_undefined&#34;
    level : str, optional
        logging.level, by default &#34;INFO&#34;
    sample_rate: float, optional
        sample rate for debug calls within execution context defaults to 0.0
    stream: sys.stdout, optional
        valid output for a logging stream, by default sys.stdout

    Example
    -------
    **Setups structured logging in JSON for Lambda functions with explicit service name**

        &gt;&gt;&gt; from aws_lambda_powertools import Logger
        &gt;&gt;&gt; logger = Logger(service=&#34;payment&#34;)
        &gt;&gt;&gt;
        &gt;&gt;&gt; def handler(event, context):
                logger.info(&#34;Hello&#34;)

    **Setups structured logging in JSON for Lambda functions using env vars**

        $ export POWERTOOLS_SERVICE_NAME=&#34;payment&#34;
        $ export POWERTOOLS_LOGGER_SAMPLE_RATE=0.01 # 1% debug sampling
        &gt;&gt;&gt; from aws_lambda_powertools import Logger
        &gt;&gt;&gt; logger = Logger()
        &gt;&gt;&gt;
        &gt;&gt;&gt; def handler(event, context):
                logger.info(&#34;Hello&#34;)

    **Append payment_id to previously setup structured log logger**

        &gt;&gt;&gt; from aws_lambda_powertools import Logger
        &gt;&gt;&gt; logger = Logger(service=&#34;payment&#34;)
        &gt;&gt;&gt;
        &gt;&gt;&gt; def handler(event, context):
                logger.structure_logs(append=True, payment_id=event[&#34;payment_id&#34;])
                logger.info(&#34;Hello&#34;)

    Parameters
    ----------
    logging : logging.Logger
        Inherits Logger
    service: str
        name of the service to create the logger for, &#34;service_undefined&#34; by default
    level: str, int
        log level, INFO by default
    sampling_rate: float
        debug log sampling rate, 0.0 by default
    stream: sys.stdout
        log stream, stdout by default

    Raises
    ------
    InvalidLoggerSamplingRateError
        When sampling rate provided is not a float
    &#34;&#34;&#34;

    def __init__(
        self,
        service: str = None,
        level: Union[str, int] = None,
        sampling_rate: float = None,
        stream: sys.stdout = None,
        **kwargs,
    ):
        self.service = service or os.getenv(&#34;POWERTOOLS_SERVICE_NAME&#34;) or &#34;service_undefined&#34;
        self.sampling_rate = sampling_rate or os.getenv(&#34;POWERTOOLS_LOGGER_SAMPLE_RATE&#34;) or 0.0
        self.log_level = level or os.getenv(&#34;LOG_LEVEL&#34;) or logging.INFO
        self.handler = logging.StreamHandler(stream) if stream is not None else logging.StreamHandler(sys.stdout)
        self._default_log_keys = {&#34;service&#34;: self.service, &#34;sampling_rate&#34;: self.sampling_rate}
        self.log_keys = copy.copy(self._default_log_keys)

        super().__init__(name=self.service, level=self.log_level)

        try:
            if self.sampling_rate and random.random() &lt;= float(self.sampling_rate):
                logger.debug(&#34;Setting log level to Debug due to sampling rate&#34;)
                self.log_level = logging.DEBUG
        except ValueError:
            raise InvalidLoggerSamplingRateError(
                f&#34;Expected a float value ranging 0 to 1, but received {self.sampling_rate} instead. Please review POWERTOOLS_LOGGER_SAMPLE_RATE environment variable.&#34;  # noqa E501
            )

        self.setLevel(self.log_level)
        self.structure_logs(**kwargs)
        self.addHandler(self.handler)

    def inject_lambda_context(self, lambda_handler: Callable[[Dict, Any], Any] = None, log_event: bool = False):
        &#34;&#34;&#34;Decorator to capture Lambda contextual info and inject into struct logging

        Parameters
        ----------
        log_event : bool, optional
            Instructs logger to log Lambda Event, by default False

        Environment variables
        ---------------------
        POWERTOOLS_LOGGER_LOG_EVENT : str
            instruct logger to log Lambda Event (e.g. `&#34;true&#34;, &#34;True&#34;, &#34;TRUE&#34;`)

        Example
        -------
        **Captures Lambda contextual runtime info (e.g memory, arn, req_id)**

            from aws_lambda_powertools import Logger

            logger = Logger(service=&#34;payment&#34;)

            @logger.inject_lambda_context
            def handler(event, context):
                logger.info(&#34;Hello&#34;)

        **Captures Lambda contextual runtime info and logs incoming request**

            from aws_lambda_powertools import Logger

            logger = Logger(service=&#34;payment&#34;)

            @logger.inject_lambda_context(log_event=True)
            def handler(event, context):
                logger.info(&#34;Hello&#34;)

        Returns
        -------
        decorate : Callable
            Decorated lambda handler
        &#34;&#34;&#34;

        # If handler is None we&#39;ve been called with parameters
        # Return a partial function with args filled
        if lambda_handler is None:
            logger.debug(&#34;Decorator called with parameters&#34;)
            return functools.partial(self.inject_lambda_context, log_event=log_event)

        log_event_env_option = str(os.getenv(&#34;POWERTOOLS_LOGGER_LOG_EVENT&#34;, &#34;false&#34;))
        log_event = strtobool(log_event_env_option) or log_event

        @functools.wraps(lambda_handler)
        def decorate(event, context):
            if log_event:
                logger.debug(&#34;Event received&#34;)
                self.info(event)

            lambda_context = build_lambda_context_model(context)
            cold_start = _is_cold_start()

            self.structure_logs(cold_start=cold_start, **lambda_context.__dict__)
            return lambda_handler(event, context)

        return decorate

    def structure_logs(self, append: bool = False, **kwargs):
        &#34;&#34;&#34;Sets logging formatting to JSON.

        Optionally, it can append keyword arguments
        to an existing logger so it is available
        across future log statements.

        Last keyword argument and value wins if duplicated.

        Parameters
        ----------
        append : bool, optional
            [description], by default False
        &#34;&#34;&#34;
        self.handler.setFormatter(JsonFormatter(**self._default_log_keys, **kwargs))

        if append:
            new_keys = {**self.log_keys, **kwargs}
            self.handler.setFormatter(JsonFormatter(**new_keys))

        self.log_keys.update(**kwargs)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>logging.Logger</li>
<li>logging.Filterer</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="aws_lambda_powertools.logging.logger.Logger.inject_lambda_context"><code class="name flex">
<span>def <span class="ident">inject_lambda_context</span></span>(<span>self, lambda_handler=None, log_event=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Decorator to capture Lambda contextual info and inject into struct logging</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>log_event</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Instructs logger to log Lambda Event, by default False</dd>
</dl>
<h2 id="environment-variables">Environment variables</h2>
<dl>
<dt><strong><code>POWERTOOLS_LOGGER_LOG_EVENT</code></strong> :&ensp;<code>str</code></dt>
<dd>instruct logger to log Lambda Event (e.g. <code>"true", "True", "TRUE"</code>)</dd>
</dl>
<h2 id="example">Example</h2>
<p><strong>Captures Lambda contextual runtime info (e.g memory, arn, req_id)</strong></p>
<pre><code>from aws_lambda_powertools import Logger

logger = Logger(service="payment")

@logger.inject_lambda_context
def handler(event, context):
    logger.info("Hello")
</code></pre>
<p><strong>Captures Lambda contextual runtime info and logs incoming request</strong></p>
<pre><code>from aws_lambda_powertools import Logger

logger = Logger(service="payment")

@logger.inject_lambda_context(log_event=True)
def handler(event, context):
    logger.info("Hello")
</code></pre>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>decorate</code></strong> :&ensp;<code>Callable</code></dt>
<dd>Decorated lambda handler</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def inject_lambda_context(self, lambda_handler: Callable[[Dict, Any], Any] = None, log_event: bool = False):
    &#34;&#34;&#34;Decorator to capture Lambda contextual info and inject into struct logging

    Parameters
    ----------
    log_event : bool, optional
        Instructs logger to log Lambda Event, by default False

    Environment variables
    ---------------------
    POWERTOOLS_LOGGER_LOG_EVENT : str
        instruct logger to log Lambda Event (e.g. `&#34;true&#34;, &#34;True&#34;, &#34;TRUE&#34;`)

    Example
    -------
    **Captures Lambda contextual runtime info (e.g memory, arn, req_id)**

        from aws_lambda_powertools import Logger

        logger = Logger(service=&#34;payment&#34;)

        @logger.inject_lambda_context
        def handler(event, context):
            logger.info(&#34;Hello&#34;)

    **Captures Lambda contextual runtime info and logs incoming request**

        from aws_lambda_powertools import Logger

        logger = Logger(service=&#34;payment&#34;)

        @logger.inject_lambda_context(log_event=True)
        def handler(event, context):
            logger.info(&#34;Hello&#34;)

    Returns
    -------
    decorate : Callable
        Decorated lambda handler
    &#34;&#34;&#34;

    # If handler is None we&#39;ve been called with parameters
    # Return a partial function with args filled
    if lambda_handler is None:
        logger.debug(&#34;Decorator called with parameters&#34;)
        return functools.partial(self.inject_lambda_context, log_event=log_event)

    log_event_env_option = str(os.getenv(&#34;POWERTOOLS_LOGGER_LOG_EVENT&#34;, &#34;false&#34;))
    log_event = strtobool(log_event_env_option) or log_event

    @functools.wraps(lambda_handler)
    def decorate(event, context):
        if log_event:
            logger.debug(&#34;Event received&#34;)
            self.info(event)

        lambda_context = build_lambda_context_model(context)
        cold_start = _is_cold_start()

        self.structure_logs(cold_start=cold_start, **lambda_context.__dict__)
        return lambda_handler(event, context)

    return decorate</code></pre>
</details>
</dd>
<dt id="aws_lambda_powertools.logging.logger.Logger.structure_logs"><code class="name flex">
<span>def <span class="ident">structure_logs</span></span>(<span>self, append=False, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Sets logging formatting to JSON.</p>
<p>Optionally, it can append keyword arguments
to an existing logger so it is available
across future log statements.</p>
<p>Last keyword argument and value wins if duplicated.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>append</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>[description], by default False</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def structure_logs(self, append: bool = False, **kwargs):
    &#34;&#34;&#34;Sets logging formatting to JSON.

    Optionally, it can append keyword arguments
    to an existing logger so it is available
    across future log statements.

    Last keyword argument and value wins if duplicated.

    Parameters
    ----------
    append : bool, optional
        [description], by default False
    &#34;&#34;&#34;
    self.handler.setFormatter(JsonFormatter(**self._default_log_keys, **kwargs))

    if append:
        new_keys = {**self.log_keys, **kwargs}
        self.handler.setFormatter(JsonFormatter(**new_keys))

    self.log_keys.update(**kwargs)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="aws_lambda_powertools.logging" href="index.html">aws_lambda_powertools.logging</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="aws_lambda_powertools.logging.logger.json_formatter" href="#aws_lambda_powertools.logging.logger.json_formatter">json_formatter</a></code></li>
<li><code><a title="aws_lambda_powertools.logging.logger.log_metric" href="#aws_lambda_powertools.logging.logger.log_metric">log_metric</a></code></li>
<li><code><a title="aws_lambda_powertools.logging.logger.logger_inject_lambda_context" href="#aws_lambda_powertools.logging.logger.logger_inject_lambda_context">logger_inject_lambda_context</a></code></li>
<li><code><a title="aws_lambda_powertools.logging.logger.logger_setup" href="#aws_lambda_powertools.logging.logger.logger_setup">logger_setup</a></code></li>
<li><code><a title="aws_lambda_powertools.logging.logger.set_package_logger" href="#aws_lambda_powertools.logging.logger.set_package_logger">set_package_logger</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="aws_lambda_powertools.logging.logger.JsonFormatter" href="#aws_lambda_powertools.logging.logger.JsonFormatter">JsonFormatter</a></code></h4>
<ul class="">
<li><code><a title="aws_lambda_powertools.logging.logger.JsonFormatter.format" href="#aws_lambda_powertools.logging.logger.JsonFormatter.format">format</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="aws_lambda_powertools.logging.logger.Logger" href="#aws_lambda_powertools.logging.logger.Logger">Logger</a></code></h4>
<ul class="">
<li><code><a title="aws_lambda_powertools.logging.logger.Logger.inject_lambda_context" href="#aws_lambda_powertools.logging.logger.Logger.inject_lambda_context">inject_lambda_context</a></code></li>
<li><code><a title="aws_lambda_powertools.logging.logger.Logger.structure_logs" href="#aws_lambda_powertools.logging.logger.Logger.structure_logs">structure_logs</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.7.5</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>